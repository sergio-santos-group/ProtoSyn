<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calculators Section Â· ProtoSyn.jl</title><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="ProtoSyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">ProtoSyn.jl</a></span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../../../getting-started/installation/">Installation</a></li><li><a class="tocitem" href="../../../../getting-started/first-steps/">First steps</a></li><li><a class="tocitem" href="../../../../getting-started/examples/">Examples</a></li></ul></li><li><span class="tocitem">ProtoSyn API</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-1-2" type="checkbox"/><label class="tocitem" for="menuitem-3-1-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../methods/graph/">Graph</a></li><li><a class="tocitem" href="../../methods/state/">State</a></li><li><a class="tocitem" href="../../methods/pose/">Pose</a></li><li><a class="tocitem" href="../../methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../methods/other/">Auxiliary methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1-3"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Calculators Section</a><ul class="internal"><li><a class="tocitem" href="#Energy-functions-and-energy-function-components"><span>Energy functions &amp; energy function components</span></a></li><li><a class="tocitem" href="#Creating-a-custom-EnergyFunctionComponent"><span>Creating a custom EnergyFunctionComponent</span></a></li><li><a class="tocitem" href="#ProtoSyn-acceleration-types"><span>ProtoSyn acceleration types</span></a></li><li><a class="tocitem" href="#Verlet-lists"><span>Verlet lists</span></a></li><li><a class="tocitem" href="#Distance-matrix-calculation"><span>Distance matrix calculation</span></a></li><li><a class="tocitem" href="#Available-EnergyFunctionComponents"><span>Available EnergyFunctionComponents</span></a></li></ul></li><li><a class="tocitem" href="../torchani/">TorchANI</a></li><li><a class="tocitem" href="../bond-distance-restraint/">Bond distance Restraint</a></li><li><a class="tocitem" href="../potential-restraints/">Potential Restraints</a></li><li><a class="tocitem" href="../electrostatics/">Electrostatics</a></li><li><a class="tocitem" href="../gb-solvation/">Generalized Born</a></li><li><a class="tocitem" href="../sasa/">SASA</a></li><li><a class="tocitem" href="../hydrogen-bonds/">Hydrogen Bonds</a></li><li><a class="tocitem" href="../radius-gyration/">Radius of gyration</a></li><li><a class="tocitem" href="../custom-ref-energy/">Custom reference energy</a></li><li><a class="tocitem" href="../ref15/">REF-15</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-4" type="checkbox"/><label class="tocitem" for="menuitem-3-1-4"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mutators/mutators-section/">Mutators Section</a></li><li><a class="tocitem" href="../../mutators/mutators-dihedral/">Dihedral Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-crankshaft/">Crankshaft Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-rigid-body/">Rigid Body Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-backrub/">Backrub Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-compound/">Compound Mutators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-5" type="checkbox"/><label class="tocitem" for="menuitem-3-1-5"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../drivers/drivers-section/">Drivers Section</a></li><li><a class="tocitem" href="../../drivers/drivers-monte-carlo/">Monte Carlo</a></li><li><a class="tocitem" href="../../drivers/drivers-steepest-descent/">Steepest Descent</a></li><li><a class="tocitem" href="../../drivers/drivers-ils/">ILS</a></li><li><a class="tocitem" href="../../drivers/drivers-compound/">Compound Driver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-6" type="checkbox"/><label class="tocitem" for="menuitem-3-1-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../submodules/external-packages/">External packages</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Peptides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../peptides/types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-2-3" type="checkbox"/><label class="tocitem" for="menuitem-3-2-3"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../../peptides/methods/graph/">Graph</a></li><li><a class="tocitem" href="../../../peptides/methods/state/">State</a></li><li><a class="tocitem" href="../../../peptides/methods/pose/">Pose</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-4" type="checkbox"/><label class="tocitem" for="menuitem-3-2-4"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/calculators/potential-restraints/">Potential Restraints</a></li><li><a class="tocitem" href="../../../peptides/calculators/electrostatics/">Electrostatics</a></li><li><a class="tocitem" href="../../../peptides/calculators/sasa/">SASA</a></li><li><a class="tocitem" href="../../../peptides/calculators/natural-frequency/">Natural frequency</a></li><li><a class="tocitem" href="../../../peptides/calculators/ss-propensity/">Secondary structure propensity</a></li><li><a class="tocitem" href="../../../peptides/calculators/caterpillar-solvation/">Caterpilar solvation model</a></li><li><a class="tocitem" href="../../../peptides/calculators/seqdes/">SeqDes model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-5" type="checkbox"/><label class="tocitem" for="menuitem-3-2-5"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/mutators/rotamer/">Rotamer Mutator</a></li><li><a class="tocitem" href="../../../peptides/mutators/design/">Design Mutator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-6" type="checkbox"/><label class="tocitem" for="menuitem-3-2-6"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/drivers/rotamer-blitz-driver/">Rotamer Blitz</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-7" type="checkbox"/><label class="tocitem" for="menuitem-3-2-7"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../../peptides/submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../../peptides/submodules/rotamers/">Rotamers</a></li><li><a class="tocitem" href="../../../peptides/submodules/external-packages/">External packages</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Materials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-3-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/methods/lattices/">Lattices</a></li><li><a class="tocitem" href="../../../materials/methods/carbons/">Carbons</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Sugars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/submodules/builder/">Builder</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../common/introduction/">Introduction</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ProtoSyn API</a></li><li><a class="is-disabled">Core</a></li><li><a class="is-disabled">Calculators</a></li><li class="is-active"><a href>Calculators Section</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calculators Section</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/master/docs/src/protosyn-api/core/calculators/calculators-section.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Calculators-section"><a class="docs-heading-anchor" href="#Calculators-section">Calculators section</a><a id="Calculators-section-1"></a><a class="docs-heading-anchor-permalink" href="#Calculators-section" title="Permalink"></a></h1><p>Each module in ProtoSyn may contain a <a href="#Calculators-section">Calculators section</a> which includes types and methods that allow ProtoSyn to measure the fitness of a given <a href="../../types/#ProtoSyn.State"><code>State</code></a>, according to a specific <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instance. The resulting energy value is stored in the <a href="../../types/#ProtoSyn.State"><code>State</code></a><code>.e</code> field, as a Dictionary of <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances. The <code>:total</code> energy of the system is the sum of each component contribution. Each module in ProtoSyn (such as the <a href="../../../peptides/introduction/#Peptides">Peptides</a> module) adds new components and methods specific to that module&#39;s purpose. As a starting point, the <code>Core</code> module sets up all necessary types and methods transversal to all modules, as well as a few basic energetic components. In the next section, a further exploration on how to develop and set-up custom <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instances is provided, organized in the following sections:</p><ul><li><a href="#Energy-functions-and-energy-function-components">Energy functions &amp; energy function components</a></li><li><a href="#Creating-a-custom-EnergyFunctionComponent">Creating a custom EnergyFunctionComponent</a></li><li><a href="#ProtoSyn-acceleration-types">ProtoSyn acceleration types</a></li><li><a href="#Verlet-lists">Verlet lists</a></li><li><a href="#Distance-matrix-calculation">Distance matrix calculation</a></li><li><a href="#Available-EnergyFunctionComponents">Available EnergyFunctionComponents</a></li></ul><h2 id="Energy-functions-and-energy-function-components"><a class="docs-heading-anchor" href="#Energy-functions-and-energy-function-components">Energy functions &amp; energy function components</a><a id="Energy-functions-and-energy-function-components-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-functions-and-energy-function-components" title="Permalink"></a></h2><p>An <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> is the main high-level object of ProtoSyn for energy calculation of a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> instance, whose building blocks are the <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.EnergyFunctionComponent" href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>ProtoSyn.Calculators.EnergyFunctionComponent</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnergyFunctionComponent(name::String, calc::Function, settings::Dict{Symbol, Any}, Î±::T, update_forces::Bool)</code></pre><p>Return a new <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instance with the given <code>name</code>. An <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> object is responsible to calculate an energetic contribution to the system, based on a given interaction, model or restraint (for example, a <em>Bond Distance Restraint</em> is responsible to calculate the energetic contribution by bonds with lengths superior to a given threshold). The <code>:total</code> energy of a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> is, therefore, the sum of all <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> applied in a given calculation. Each  <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> has a <code>calc</code> <code>Function</code> that receives a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> and outputs an energy value. Optionally, this <code>calc</code> <code>Function</code> can also return a set of forces felt on all considered atoms, based on the potential or model used, which is calculated if the <code>update_forces</code> flag is set to <code>true</code>. For a more detailed explanation see the <a href="#Creating-a-custom-EnergyFunctionComponent">Creating a custom EnergyFunctionComponent</a> section of the documentation). Additionally, certain <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances can have a <code>settings</code> dictionary, containing kwargs that are passed to the <code>calc</code> <code>Function</code>. These usually parametrize and fine tune the calculations perform (such as setting the flat bottom restraint distances, as an example). When calling an <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> calculation from an <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>, the relative weight of this <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> in relation to others is given by the <code>Î±</code> field.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code> - The name of this <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a>. Used to index by <code>name</code> when in an <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>;</li><li><code>calc::Function</code> - The calculation <code>Function</code> used to calculate this contribution;</li><li><code>settings::Dict{Symbol, Any}</code> - (Optional) A dictionary of kwargs provided to the <code>calc</code> <code>Function</code>, parameterizing its usage;</li><li><code>Î±::T</code> - The relative weight of this <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> when in an <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>;</li><li><code>update_forces::Bool</code> - Toggle forces calculation by this <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> when in an <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>. </li></ul><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint()
         Name : Bond_Distance_Restraint
   Weight (Î±) : 1.0
Update forces : true
      Setings :
          :x0 =&gt; 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Calculators/energy_function_component.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.EnergyFunction" href="#ProtoSyn.Calculators.EnergyFunction"><code>ProtoSyn.Calculators.EnergyFunction</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnergyFunction(components::Vector{EnergyFunctionComponent}, clean_cache_every::Int16, cache::Int16, components_by_name::Dict{String, Int}, selection::AbstractSelection, update_forces::Bool)</code></pre><p>Construct and return a new <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instance. An <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> is a collection of <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances, where each of these components calculates an energetic contribution to the <code>:total</code> energy and forces acting on a system. An <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> can be retrieved by its index or by its name (as saved in <code>components_by_name</code>). The <code>AbstractSelection</code> <code>selection</code> defines the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> selection this <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> is applied to. If  inner <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances also have <code>AbstractSelection</code> selections defined, the resulting selection will be the intersection between  both. The <code>update_forces</code> sets whether to calculate and update the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <a href="../../types/#state-types">State</a> forces. The Julia cache is automatically cleaned by garbage collection. However, in certain cases (such as using the <a href="../torchani/#TorchANI">TorchANI</a> <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a>), a manual call to garbage collection is necessary (see <a href="https://discourse.julialang.org/t/using-gpu-via-pycall-causes-non-reusable-memory-allocation/55140/4">Issue 55140</a>). In such cases, the <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> object has an internal <code>cache</code> that is cleaned (by calling garbage collection) at intervals of <code>clean_cache_every</code> calls. This interval is automatically adjusted down by measuring the current load on the GPU, calling garbage collection once the memory allocation is greater than <code>ProtoSyn.Units.max_gpu_allocation</code>.</p><pre><code class="nohighlight hljs">EnergyFunction([::Type{T}])</code></pre><p>Construct and return an empty <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instance. The <code>:clean_cache_every</code> field is set to <code>ProtoSyn.Units.defaultCleanCacheEvery</code>,  the <code>AbstractSelection</code> <code>selection</code> field is defined as an atomic <a href="../../submodules/selections/#ProtoSyn.TrueSelection"><code>TrueSelection</code></a> and <code>update_forces</code> is set to <code>false.</code></p><pre><code class="nohighlight hljs">EnergyFunction(components::Vector{EnergyFunctionComponent{T}}) where {T &lt;: AbstractFloat}</code></pre><p>Construct and return a new <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instance filled with the given list of <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances <code>components</code>. The <code>:clean_cache_every</code> field is set to <code>ProtoSyn.Units.defaultCleanCacheEvery</code>, the <code>AbstractSelection</code> <code>selection</code> field is defined as an atomic <a href="../../submodules/selections/#ProtoSyn.TrueSelection"><code>TrueSelection</code></a> and <code>update_forces</code> is set to <code>false.</code></p><p><strong>Fields</strong></p><ul><li><code>components::Vector{EnergyFunctionComponent}</code> - The list of <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances in this <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>;</li><li><code>clean_cache_every::Int16</code> - Forcefully call garbage collection every <code>N</code> calls;</li><li><code>cache::Int16</code> - Current number of calls performed. Resets to zero every <code>clean_cache_every</code>;</li><li><code>components_by_name::Dict{String, Int}</code> - The list of <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances in this <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>, indexed by <code>:name</code>;</li><li><code>selection::AbstractSelection</code> - The <code>AbstractSelection</code> selecting <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances to apply this <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> to;</li><li><code>update_forces::Bool</code> - Whether to calculate and update forces with this <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>.</li></ul><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; energy_function = ProtoSyn.Calculators.EnergyFunction()
ð²  Energy Function (0 components):
+----------------------------------------------------------------------+
| Index | Component name                                | Weight (Î±)   |
+----------------------------------------------------------------------+
+----------------------------------------------------------------------+
 â Update forces: false
 â Selection: Set
 âââ TrueSelection (Atom)

julia&gt; push!(energy_function, Calculators.Restraints.get_default_bond_distance_restraint())
ð²  Energy Function (1 components):
+----------------------------------------------------------------------+
| Index | Component name                                | Weight (Î±)   |
+----------------------------------------------------------------------+
| 1     | Bond_Distance_Rest                            |      1.000   |
+----------------------------------------------------------------------+
 â Update forces: false
 â Selection: Set
 âââ TrueSelection (Atom)

 julia&gt; energy_function[&quot;Bond_Distance_Rest&quot;].Î± = 0.5
 0.5

julia&gt; energy_function
ð²  Energy Function (1 components):
+----------------------------------------------------------------------+
| Index | Component name                                | Weight (Î±)   |
+----------------------------------------------------------------------+
| 1     | Bond_Distance_Rest                            |      0.500   |
+----------------------------------------------------------------------+
 â Update forces: false
 â Selection: Set
 âââ TrueSelection (Atom)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Calculators/energy_function.jl#L3-L90">source</a></section></article><p>An <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instance is actually a <strong>functor</strong>, meaning it is callable in order to apply any energy function type to any <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> instance, using the following signature:</p><pre><code class="language-julia hljs">(energy_function::EnergyFunction)(pose::Pose, update_forces::Bool = false)</code></pre><p>An application example is provided bellow, using the <a href="https://aiqm.github.io/torchani/">TorchANI</a> model as the sole <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a>:</p><pre><code class="language-julia hljs">julia&gt; torchani = Calculators.TorchANI.get_default_torchani_model()
ð§  Energy Function Component:
+---------------------------------------------------+
| Name           | TorchANI_ML_Model                |
| Alpha (Î±)      | 1.0                              |
| Update forces  | true                             |
| Calculator     | calc_torchani_model              |
+---------------------------------------------------+
 |    +----------------------------------------------------------------------------------+
 âââ  â Settings                      | Value                                            |
 |    +----------------------------------------------------------------------------------+
 |    | model                         | 3                                                |
 |    +----------------------------------------------------------------------------------+
 |    
 âââ  â  Selection: nothing


julia&gt; energy_function = Calculators.EnergyFunction([torchani])
ð²  Energy Function (1 components):
+----------------------------------------------------------------------+
| Index | Component name                                | Weight (Î±)   |
+----------------------------------------------------------------------+
| 1     | TorchANI_ML_Model                             |       1.00   |
+----------------------------------------------------------------------+
 â Update forces: false
 â Selection: Set
 âââ TrueSelection (Atom)


julia&gt; energy_function(pose)
-0.12573561072349548

julia&gt; energy_function(pose, update_forces_overwrite = true) # Calculating forces ...

-0.1257355958223343

julia&gt; pose.state.f
3Ã39 Matrix{Float64}:
  0.105621      0.0429586   -0.213427     0.0153761    0.0157833    -0.378909    -0.0517234   0.424317     0.0279231     0.0093389   -0.0056106   â¦   0.011298    0.00833148   0.0184882   0.00465198   0.00608612  0.00112979  -0.00733359  -0.00735081  -0.068546    0.0993318
  0.0848035    -0.0298163   -0.0332622    0.0199625    0.0200265     0.0077734   -0.0119481  -0.0495319   -0.0105625     0.00514565  -0.00300045     -0.00854456  0.00345127  -0.0185168  -0.00338795  -0.020893    0.0465067   -0.00867537  -0.0175688   -0.155421    0.116816
 -0.000401706  -2.23697e-5   0.00150126  -0.000534238  0.000625417  -0.00081389   0.0103037   0.00440437   0.000742536  -0.0176396    0.00642139      0.0106405   0.00660759  -0.0158945  -0.0291799   -0.00430939  0.076713    -0.0245234   -0.0209203    0.00455828  0.00180759</code></pre><p><img src="../../../../assets/ProtoSyn-energy-function.png" alt="ProtoSyn Energy Function"/></p><p><strong>Figure 1 |</strong> A diagram representation of the <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> organization as a set of <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances. Each component contribution is summed to evaluate the <code>:total</code> energy of the system, according to each component&#39;s scaling factor <code>É</code> (in this example, <code>1.0</code> for the <em>TorchANI Ensemble</em> <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> and <code>0.8</code> for the <em>Contact Map</em> <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a>). Some components may be able to calculate the set of forces acting on each atom of the system, in which case this contribution can be toggled <em>on</em> and <em>off</em> by the <code>:update_forces</code> flag. Furthermore, each component may be parametrized by a set of options. In this example, the <em>Contact Map</em> <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> can be further parametrized by setting the <code>:d1</code>, <code>:d2</code>, <code>:d3</code> and <code>:d4</code> values (controlling the flat bottom restraint potential), as well as the <code>:selection</code> on which to act and the <code>:mask</code> applied. Such settings are specific to each type of <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> and are explored in detail in each entry in this manual.</p><h2 id="Creating-a-custom-EnergyFunctionComponent"><a class="docs-heading-anchor" href="#Creating-a-custom-EnergyFunctionComponent">Creating a custom EnergyFunctionComponent</a><a id="Creating-a-custom-EnergyFunctionComponent-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-custom-EnergyFunctionComponent" title="Permalink"></a></h2><p>As stated before, an <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> is mostly a smart wrapper around a <code>:calc</code> <code>Function</code> responsible for calculating a given energetic contribution based on a specific method, model or restraint type (as an example). Therefore, when developing custom <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances, certain aspects need to be taken into consideration. The following section lists particular restraints when creating custom <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances.</p><ol><li>The <code>:calc</code> <code>Function</code> signature:</li></ol><p>When being called from an <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instance, ProtoSyn expects the following <code>calc</code> <code>Function</code> signature.</p><pre><code class="language-julia hljs">calc(::A, pose::Pose, sele::Opt{AbstractSelection}, update_forces::Bool = false; kwarg1::Type{kwarg1} = default_value1, kwarg2::Type{kwarg2} = default_value2, ...) where {A &lt;: ProtoSyn.AbstractAccelerationType}</code></pre><p>The <code>::A</code> (see the <a href="#ProtoSyn-acceleration-types">ProtoSyn acceleration types</a> section), <code>pose::Pose</code>, <code>sele::AbstractSelection</code> and <code>update_forces::Bool = false</code> arguments are necessary and expected. Optionally, these can be followed by a variable number of arguments (kwargs), parameterizing and fine-tuning the usage of the <code>calc</code> <code>Function</code>. When calling this <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> from an <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>, these kwargs are passed from the <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a><code>.settings</code> dictionary, and can therefore be automatically and continuously adjusted in a simulation. Since it may happen that one or more kwargs may not be defined in the <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a><code>.settings</code>, defining a default value for each of the kwargs is considered a good practice when creating a custom <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a>.</p><p>Example of potential <code>:calc</code> functions:</p><pre><code class="language-julia hljs"># Without restricting the acceleration type
function my_calc(::A, pose, sele::Opt{AbstractSelection}, update_forces::Bool) where {A &lt;: ProtoSyn.AbstractAccelerationType}
    (...)
end

# Restricting the acceleration type and defining additional settings (with default values)
function my_calc(::ProtoSyn.CUDA_2, pose::Pose, sele::Opt{AbstractSelection}, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, mask::MaskMap = nothing) where {T &lt;: AbstractFloat}
    (...)
end</code></pre><ol><li>the <code>:calc</code> function returning values:</li></ol><p>ProtoSyn expects the <code>:calc</code> function to return 2 objects: firstly, the energy value, as an AbstractFloat (<code>Float64</code>, for example), and secondly, a <code>Matrix</code> of forces acting on the system. If a particular <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> does not calculate forces, it can optionally return <code>nothing</code>. Any extra returning values besides these (as long as these are the first, in this order), can be returned but will be ignored in the context of an <a href="#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a>.</p><pre><code class="language-julia hljs">function my_calc(::A, pose, sele::Opt{AbstractSelection}, update_forces::Bool) where {A &lt;: ProtoSyn.AbstractAccelerationType}
    (...)
    return energy, forces
end</code></pre><ol><li>The <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a><code>.settings</code> field</li></ol><p>As previously stated, the <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a><code>.settings</code> are optional. If present, these are passed to the <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a><code>.calc</code> <code>Function</code> as kwargs, and therefore should match and have the same name (as a <code>Symbol</code> instead). This allows for easy access and modification of internal parameters of the calculation on the fly.</p><p>Examples:</p><pre><code class="language-julia hljs">Dict{Symbol, Any}(:d1 =&gt; 1.0, :d2 =&gt; 3.0, :d3 =&gt; Inf, :d4 =&gt; Inf, :mask =&gt; Calculators.get_diagonal_mask(pose, an&quot;C&quot;))</code></pre><h2 id="ProtoSyn-acceleration-types"><a class="docs-heading-anchor" href="#ProtoSyn-acceleration-types">ProtoSyn acceleration types</a><a id="ProtoSyn-acceleration-types-1"></a><a class="docs-heading-anchor-permalink" href="#ProtoSyn-acceleration-types" title="Permalink"></a></h2><p>Certain <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances in ProtoSyn require specific software and hardware on the machine performing the calculation, or at least have specific implementations of the code based on the availability or not of said features (for example, certain functions have specific implementations for CUDA and GPU acceleration). For this reason, ProtoSyn defines 3 levels of acceleration (3 different acceleration types, loosely based on <a href="https://www.geeksforgeeks.org/computer-architecture-flynns-taxonomy/">Flynn&#39;s Taxonomy</a>):</p><ul><li><code>SISD_0</code> - <a href="https://en.wikipedia.org/wiki/SISD">Single Instruction Single Data</a>: uses CPU, should work on most modern processors;</li><li><code>SIMD_1</code> - <a href="https://en.wikipedia.org/wiki/SIMD">Single Instruction Multiple Data</a>: uses CPU, parallelizes a single instruction in a vector of data, available in modern processors with <a href="https://wikipedia.org/wiki/MMX">MMX</a>, <a href="https://wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> and <a href="https://wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>/<a href="https://en.wikipedia.org/wiki/AVX-512">AVX-512</a> technologies, among others;</li><li><code>CUDA_2</code> - <a href="https://en.wikipedia.org/wiki/CUDA">Compute Unified Device Architecture</a>: parallel computing platform and API enabling GPU acceleration of code. If CUDA is available, this is the default acceleration type set up in ProtoSyn.</li></ul><p>At start-up, ProtoSyn tries to identify the available software and hardware available and sets the fastest acceleration type possible as <code>ProtoSyn.acceleration.active</code>. This can, however, be overridden:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ProtoSyn.acceleration.active</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: ProtoSyn not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ProtoSyn.acceleration.active = ProtoSyn.SIMD_1</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: ProtoSyn not defined</code></pre><h2 id="Verlet-lists"><a class="docs-heading-anchor" href="#Verlet-lists">Verlet lists</a><a id="Verlet-lists-1"></a><a class="docs-heading-anchor-permalink" href="#Verlet-lists" title="Permalink"></a></h2><p>A <a href="https://en.wikipedia.org/wiki/Verlet_list">Verlet list</a> is a common data structure in molecular manipulation and simulation softwares that maintains a list of particles inside a given cut-off distance to eachother. The main objective of Verlet lists is to speed up calculations by ignoring most of the long-distance interactions between <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances, as these would have negligent effects in the simulation, while reducing the amount of memory allocated as a whole. Note that, given the movement and displacement of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in a simulation, this list rapidly becomes obsolete and needs to be re-updated.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.VerletList" href="#ProtoSyn.Calculators.VerletList"><code>ProtoSyn.Calculators.VerletList</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VerletList(size::Int, capacity::Int, cutoff::Float64, offset::Vector{Int}, list::Vector{Int})</code></pre><p>Hold information regarding the neighbouring particles of each particle in the system (with number of particles <code>size</code>). A <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> is comprised of two arrays: the <code>list</code>, containing the neighbouring atoms <code>j</code> of atom <code>i</code>, with sequential atoms divided by an invalid <code>-1</code> entry; and the <code>offset</code> array, containing the positions in array <code>list</code> for each atom <code>i</code>. Neighbouring atoms are defined as having a distance bellow the defined <code>cutoff</code>. The main objective of a <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> is to speed up calculations (by ignoring long-range interactions between <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances) and to lower the total amount of memory allocated (the number of allocated <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> entries is at most the <code>capacity</code> of the <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a>). Note that, given the motion of particles in a simulation, a <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> can quickly become obsolete, and needs to be updated using <a href="#ProtoSyn.Calculators.update!"><code>update!</code></a>.</p><pre><code class="nohighlight hljs">VerletList(size::Int)</code></pre><p>Creates a new <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> with infinite <code>cutoff</code> (holds all atoms in the molecule).</p><pre><code class="nohighlight hljs">VerletList(pose::Pose)</code></pre><p>Creates a new <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> with infinite <code>cutoff</code> (holds all atoms in the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a>).</p><p><strong>Fields</strong></p><ul><li><code>size::Int</code> - The number of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances this <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> makes reference to. Should be the size of <code>:offset</code> field;</li><li><code>capacity::Int</code> - Maximum number of interaction pairs listed in this <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a>; </li><li><code>cutoff::Float64</code> - Interactions are considered when the distance between two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances is less than this value;</li><li><code>offset::Vector{Int}</code> - Vector with the starting index for the neighbouring <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.id</code> entries in the <code>:list</code> field;</li><li><code>list::Vector{Int}</code> - Vector with the neighbouring <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.id</code> entries, in sectors separated by invalid entries (such as <code>-1</code>).</li></ul><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.update!"><code>update!</code></a> <a href="../../methods/state/#ProtoSyn.distance"><code>distance</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.Calculators.VerletList(4)
ProtoSyn.Calculators.VerletList(4, 4, Inf, [0, 0, 0, 0], [0, 0, 0, 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Calculators/verlet_list.jl#L17-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.update!" href="#ProtoSyn.Calculators.update!"><code>ProtoSyn.Calculators.update!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update!([::Type{ProtoSyn.SISD_0}], verlet_list::VerletList, pose::Pose, [selection::Opt{ProtoSyn.AbstractSelection} = nothing])
update!([::Type{ProtoSyn.SIMD_1}], verlet_list::VerletList, pose::Pose, [selection::Opt{ProtoSyn.AbstractSelection} = nothing])</code></pre><p>Updates the given <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> (using a <code>SISD_0</code> or <code>SIMD_1</code> acceleration approach) according to the defined &#39;verlet_list.cutoff&#39; and the given coordinates in the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> (in AoS format). If the acceletarion type is not given, the default <code>ProtoSyn.acceleration.active</code> is employed. If an <code>AbstractSelection</code> <code>selection</code> is provided, only include the pair of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances as interacting, in the <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a>, if both instances are selected. </p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.update!(verlet_list, pose)
    ...

julia&gt; ProtoSyn.Calculators.update!(verlet_list, pose, an&quot;CA&quot;)
    ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Calculators/verlet_list.jl#L105-L125">source</a></section></article><p><img src="../../../../assets/ProtoSyn-verlet-list.png" alt="ProtoSyn Verlet List"/></p><p><strong>Figure 2 |</strong> A diagram representation of the <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> organization. Usually, a <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> is comprised of two arrays: the <code>:list</code> and the <code>:offset</code>. The <code>:offset</code> vector contains 1 entry for each <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance in a given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a>, whose <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.id</code> is the index of the vector. The actual content of the vector is an index on the <code>:list</code> array, defining the starting point from which to read this vector in order to find all the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances intercating with the currently selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>. As such, the <code>:list</code> vector is a collection of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.id</code> records, with contiguous sectors separated by invalid entries (such as <code>-1</code>). Each one of these contigous sectors is a collection of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.id</code> values belonging to the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances that interact with a common <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>. As an example, consider the represented schematic. The considered range of interactions is represnted in light grey, with radius <code>a</code> and centered on the selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>2</code>. As such, the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances <code>5</code>, <code>9</code> and <code>12</code> are inside the interaction radius, and should be considered for measurement. In the accompanying <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a>, index <code>2</code> in the <code>:offset</code> vector contains value <code>4</code>. By reading the <code>:list</code> vector starting at index <code>4</code> (as indicated by the <code>:offset</code> vector) until an invalid position is found (such as <code>-1</code>), <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.id</code> <code>5</code>, <code>9</code> and <code>12</code> are found. In the same schematic, the dashed grey line indicates a &quot;moving cut-off&quot;. It&#39;s a common practice in the usage of <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> instances to accomodate <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> movement in a simulation environment, in order to reduce the number of times the <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> needs to be updated. In this case, radius <code>b</code> is added to the <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a><code>.cutoff</code>, and should be equal to <code>N x 2 x MD</code> (where <code>N</code> is the number of steps before re-updating the <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> and <code>MD</code> is the maximum displacement an <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> is allowed or expected to suffer each step of the simulation). Using this approach, <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>1</code> (in the example) should be included in the <code>:list</code> vector, at the contiguous sector related to <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>2</code>.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>As of ProtoSyn 1.1, <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> instances are only employable in distance calculations using <a href="#ProtoSyn.Calculators.distance_matrix"><code>distance_matrix</code></a> methods. However, the underlying mechanisms of <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> data structures can be useful elsewhere and are planned to be incorporated in default <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances in the future.</p></div></div><h2 id="Distance-matrix-calculation"><a class="docs-heading-anchor" href="#Distance-matrix-calculation">Distance matrix calculation</a><a id="Distance-matrix-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Distance-matrix-calculation" title="Permalink"></a></h2><p>As previously stated, the <a href="#Calculators-section">Calculators section</a> in <code>Core</code> exists mainly to set-up types and methods transversal to all ProtoSyn&#39;s <code>Calculators</code> in different modules (such as <a href="../../../peptides/introduction/#Peptides">Peptides</a>). One such method commonly employed in energy calculations is the ability to measure distance matrices. A distance matrix is a 2D matrix whose entries are the distance between the <code>X</code> and <code>Y</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, usually considering only the top triangular matrix. A full distance matrix can also be useful, as is available by using the <a href="#ProtoSyn.Calculators.full_distance_matrix"><code>full_distance_matrix</code></a> method.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.distance_matrix" href="#ProtoSyn.Calculators.distance_matrix"><code>ProtoSyn.Calculators.distance_matrix</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Calculators.distance_matrix([::A], coords::Matrix{T}) where {A, T &lt;: AbstractFloat}
Calculators.distance_matrix([::A], state::State{T}) where {A, T &lt;: AbstractFloat}
Calculators.distance_matrix([::A], pose::Pose) where {A}</code></pre><p>Return a distance matrix with the distance of all pairs of coordinates in <code>coords</code> (this should be a <code>Matrix{T}</code> in AoS format) above the triangular matrix. Instead of a <code>Matrix{T}</code> <code>coords</code>, a <a href="../../types/#ProtoSyn.State"><code>State</code></a> or <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> can be provided, in which case the coordinates considered are all the existent in the <a href="../../types/#ProtoSyn.State"><code>State</code></a> or <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a><code>.state</code>, respectively. The optional <code>A</code> parameter defines the acceleration mode used (<code>SISD_0</code>, <code>SIMD_1</code> or <code>CUDA_2</code>). If left undefined the default <code>ProtoSyn.acceleration.active</code> mode will be used. Note: Make sure the given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> in synched (using the <a href="../../methods/state/#ProtoSyn.sync!"><code>sync!</code></a> method).</p><pre><code class="nohighlight hljs">Calculators.distance_matrix([::A], pose::Pose, selection::ProtoSyn.AbstractSelection)</code></pre><p>Return a distance matrix with the distance of all pairs of atoms in the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> who are selected in the given <code>AbstractSelection</code> <code>selection</code> and above the triangular matrix. The optional <code>A</code> parameter defines the acceleration mode used (<code>SISD_0</code>, <code>SIMD_1</code> or <code>CUDA_2</code>). If left undefined the default <code>ProtoSyn.acceleration.active</code> mode will be used.</p><pre><code class="nohighlight hljs">Calculators.distance_matrix([::A], coords::Matrix{T}, verlet_list::VerletList) where {T &lt;: AbstractFloat}
Calculators.distance_matrix([::A], state::State{T}, verlet_list::VerletList) where {T &lt;: AbstractFloat}
Calculators.distance_matrix([::A], pose::Pose, verlet_list::VerletList)</code></pre><p>Return a top triangular distance matrix with the distance of all pairs of coordinates in the <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> <code>verlet_list</code>. Instead of a <code>Matrix{T}</code> <code>coords</code>, a <a href="../../types/#ProtoSyn.State"><code>State</code></a> or <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> can be provided, in which case the coordinates considered are existent in the <a href="../../types/#ProtoSyn.State"><code>State</code></a> or <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a><code>.state</code>, respectively. The optional <code>A</code> parameter defines the acceleration mode used (<code>SISD_0</code>, <code>SIMD_1</code>). If left undefined the default <code>ProtoSyn.acceleration.active</code> mode will be used. <em>Note:</em> Using <code>VerletList</code>, <code>CUDA_2</code> acceleration mode is not available. If the default <code>ProtoSyn.acceleration.active</code> is set to <code>CUDA_2</code>, <code>SIMD_1</code> will be used instead.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p><code>AbstractSelections</code> can still be applied when using <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> instances, but need to be applied when updating the lists themselves. Check <a href="#ProtoSyn.Calculators.VerletList"><code>VerletList</code></a> and <a href="#ProtoSyn.Calculators.update!"><code>update!</code></a> entries for a more in-depth look at how <a href="#Verlet-lists">Verlet lists</a> work.</p></div></div><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.full_distance_matrix"><code>full_distance_matrix</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.distance_matrix(pose.state.x)
NÃN CUDA.CuArray{Float64,2}:
    ...

julia&gt; ProtoSyn.Calculators.distance_matrix(pose, an&quot;CA&quot;)
NÃN CUDA.CuArray{Float64,2}:
    ...

julia&gt; ProtoSyn.Calculators.distance_matrix(pose, verlet_list)
NÃN CUDA.CuArray{Float64,2}:
    ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Calculators/distance_matrix.jl#L7-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.full_distance_matrix" href="#ProtoSyn.Calculators.full_distance_matrix"><code>ProtoSyn.Calculators.full_distance_matrix</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Calculators.full_distance_matrix([::A], coords::Matrix{T}) where {A, T &lt;: AbstractFloat}
Calculators.full_distance_matrix([::A], state::State{T}) where {A, T &lt;: AbstractFloat}
Calculators.full_distance_matrix([::A], pose::Pose) where {A}</code></pre><p>Return a distance matrix with the distance of <strong>all</strong> pairs of coordinates in <code>coords</code> (this should be a <code>Matrix{T}</code> in AoS format). Instead of a <code>Matrix{T}</code> <code>coords</code>, a <a href="../../types/#ProtoSyn.State"><code>State</code></a> or <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> can be provided, in which case the coordinates considered are all the existent in the <a href="../../types/#ProtoSyn.State"><code>State</code></a> or <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a><code>.state</code>, respectively. The optional <code>A</code> parameter defines the acceleration mode used (<code>SISD_0</code>, <code>SIMD_1</code> or <code>CUDA_2</code>). If left undefined the default <code>ProtoSyn.acceleration.active</code> mode will be used.</p><pre><code class="nohighlight hljs">Calculators.full_distance_matrix([::A], pose::Pose, selection::ProtoSyn.AbstractSelection)</code></pre><p>Return a distance matrix with the distance of <strong>all</strong> pairs of atoms in the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> who are selected in the given <code>AbstractSelection</code> <code>selection</code>. The optional <code>A</code> parameter defines the acceleration mode used (<code>SISD_0</code>, <code>SIMD_1</code> or <code>CUDA_2</code>). If left undefined the default <code>ProtoSyn.acceleration.active</code> mode will be used.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.distance_matrix"><code>distance_matrix</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; ProtoSyn.Calculators.full_distance_matrix(pose.state.x)
NÃN CUDA.CuArray{Float64,2}:
 ...

julia&gt; ProtoSyn.Calculators.distance_matrix(pose, an&quot;CA&quot;)
NÃN CUDA.CuArray{Float64,2}:
 ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Calculators/distance_matrix.jl#L149-L183">source</a></section></article><h2 id="Available-EnergyFunctionComponents"><a class="docs-heading-anchor" href="#Available-EnergyFunctionComponents">Available EnergyFunctionComponents</a><a id="Available-EnergyFunctionComponents-1"></a><a class="docs-heading-anchor-permalink" href="#Available-EnergyFunctionComponents" title="Permalink"></a></h2><p>Besides all the machinery to create custom energy components, ProtoSyn&#39;s <code>Core</code> module makes available some simple <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances. Since this is not a specialized module, available components should be indiferent to the type of molecular structure being evaluated. For a compelte list of all available <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances, consider using the <a href="#ProtoSyn.Calculators.show_available_energy_function_components"><code>show_available_energy_function_components</code></a> method.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.show_available_energy_function_components" href="#ProtoSyn.Calculators.show_available_energy_function_components"><code>ProtoSyn.Calculators.show_available_energy_function_components</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show_available_energy_function_components([io::IO = stdout], [m::Module = ProtoSyn.Calculators])</code></pre><p>Prints all available <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances in the provided <code>Module</code> <code>m</code> (defaults to <code>ProtoSyn.Calculators</code>) to the given <code>IO</code> <code>io</code> (defaults to <code>stdout</code>). Recursivelly searches any inner <code>Module</code>.</p><p><strong>See also</strong></p><p><a href="../../../internals/#ProtoSyn.Calculators.get_available_energy_function_components"><code>get_available_energy_function_components</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ProtoSyn.Calculators.show_available_energy_function_components(ProtoSyn.Calculators)
+------------------------------------------------------------------------------------------------+
| Index | Component name            | Function                                                   |
+------------------------------------------------------------------------------------------------+
| 1     | Custom_Ref_Energy         | ProtoSyn.Calculators.get_default_custom_ref_energy         |
| 2     | Coulomb                   | ProtoSyn.Calculators.Electrostatics.get_default_coulomb    |
| 3     | GB_Solvation              | ProtoSyn.Calculators.GB.get_default_gb                     |
+------------------------------------------------------------------------------------------------+
âââ Consider using the `?` menu to learn more about each EnergyFunctionComponent.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/44bd8c41a3aa181671371c48227125b5b12149b7/src/Core/Calculators/Calculators.jl#L103-L126">source</a></section></article><p>As of ProtoSyn 1.1, the following <a href="#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances are made available from the <code>Core</code> module, and can be further explored in the respectivelly dedicated pages of this manual:</p><ul><li><a href="../bond-distance-restraint/#Bond-Distance-Restraint">Bond Distance Restraint</a></li><li><a href="../potential-restraints/#calculators-potential-restraints">Potential restraints</a></li><li><a href="../torchani/#TorchANI">TorchANI</a> (And <a href="../torchani/#TorchANI-reference-energy-EnergyFunctionComponent">TorchANI reference energy EnergyFunctionComponent</a>)</li><li><a href="../electrostatics/#calculators-electrostatics">Electrostatics</a></li><li><a href="../gb-solvation/#Generalized-Born-Solvation">Generalized Born Solvation</a></li><li><a href="../sasa/#calculators-sasa">SASA</a></li><li><a href="../hydrogen-bonds/#Hydrogen-bonds">Hydrogen bonds</a></li><li><a href="../radius-gyration/#Radius-of-gyration">Radius of gyration</a></li><li><a href="../custom-ref-energy/#Custom-reference-energy">Custom reference energy</a></li><li><a href="../ref15/#REF-15">REF-15</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../methods/other/">Â« Auxiliary methods</a><a class="docs-footer-nextpage" href="../torchani/">TorchANI Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Tuesday 16 August 2022 14:09">Tuesday 16 August 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
